# Design Choices for the Hybrid Symbiotic Synthesis Extension

## Sub-tree Selection Heuristic
The slicer (`paynt.utils.tree_slicer.extract_subproblems`) walks the dtcontrol tree breadth-first and tracks the depth of each node. A node becomes a sub-problem candidate when (a) we encounter it before the configured `max_subtree_depth`, and (b) the subtree rooted at the node is still “large enough” – effectively, its height is at least `min_subtree_depth`. This heuristic prefers complex fragments closer to the root, where pruning has the greatest impact on the global tree size. Each candidate carries a freshly materialised `DecisionTree` instance together with a path condition that records the guards that must be satisfied to reach the node. These constraints allow both the heuristic pruner and the synthesiser hook to understand the context in which the sub-tree operates.

## Constrained State Space Formulation
Path constraints are represented as structured `PathConstraint` objects, capturing the originating variable, the comparison operator and the branch value. When the synthesiser is instantiated for a sub-problem we pass these constraints through `SynthesizerAR(path_condition=…)`, making them available to downstream consumers. The SMT encoding layer (`paynt.family.smt.FamilyEncoding`) now stores the constraint set alongside every encoding, enabling the solver to rebuild the formula if a constrained re-encode is requested. Although the current heuristic optimiser does not rephrase these predicates into Z3 clauses yet, the pathway is in place: the encoded family remembers which guard assignments should remain fixed, and the optimiser uses the same path data to honour the surrounding decisions while pruning.

## Managing the Optimality–Size Trade-off
`hybrid_synthesis.py` exposes a user-tunable `--max-loss` parameter. During every sub-problem optimisation, `SynthesizerAR.optimize_subtree` compares the original sub-tree with the candidate that results from heuristic pruning. We estimate the “loss” as the share of path conditions for which the chosen actions diverge between the original and the optimised policy (`paynt.utils.tree_slicer.estimate_policy_loss`). Only when the size shrinks *and* the computed loss stays within the user-provided bound do we accept the replacement. This guards against overly aggressive pruning: users can demand exact preservation (`--max-loss 0`) or trade a small behavioural deviation for substantial structural simplification.

## Error and Timeout Handling
The orchestrator surfaces external tool failures transparently. `run_dtcontrol` wraps the subprocess call and converts non-zero exits or timeouts into descriptive `RuntimeError`s. Within the hybrid loop the code logs every substitution decision; if the pruning heuristic produces an unacceptable candidate (either because the loss is too high or the tree fails to shrink) the orchestrator simply retains the original sub-tree and proceeds to the next candidate. Therefore, neither a dtcontrol failure nor an unsuccessful refinement aborts the workflow—users receive the best tree obtained so far together with detailed logs that explain which refinements succeeded or were skipped.

